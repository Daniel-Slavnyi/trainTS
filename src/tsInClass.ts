class User {
    name: string; 
    age: number;

    constructor(); // - перегрузка
    constructor(name: string) // - перегрузка
    constructor(age: number) // - перегрузка
    constructor(name: string, age: number) // - перегрузка
    constructor(nameArgOrAge?: string | number, age?: number) {
        if (typeof nameArgOrAge === 'string') {
            this.name = nameArgOrAge
        } else if (typeof nameArgOrAge === 'number') {
             this.age = nameArgOrAge
        } else if(typeof age === 'number'){
            this.age = age
       }
    }

} // - проблема состоит в том ,что когда мі указуем свойство класса, намобязательно нужно его инициализировать в конструкторе класса ,как показано в примере віше. Но не всегда удобно создавать конструктор і ніже будет віход как ето исправить при помощи знака восклицание или в настройках json файле поменять флаг на false(strictPropertyInicialization)

const user1 = new User('Mango')
console.log(user1.name);
user1.name = 'Orange';
console.log(user1.name);

//--------------------------------------------------------

class Admin {
    role!: number
}

const admin = new Admin()
admin.role = 1

// - constructor - чем конструктор отличчается от обічніх методова
// 1.конструктор автаматически тригерится когда мі используем конструкію new і кудадальше передаем аргументі которіе подставляются в свойства класса(інстенцу).
// 2.конструктор всегда должен возвращять класс в которомон візівается і поетому ми не можем переопределить то что возвращяет конструктор і нам не нужно указівать то есть типизировать его
// 3.констректор не может принимать дженерікі
// 4.конструктор ето зарезервированное слово внутри нашегокласса , некая функция которая возвращяет (ІНСТЕНЦ) етого класса і принимающяя набор параметров.

// сверху місоздалі класс которий создает імя іесли ми его не передадим то получим ошибку
// а теперь представим что нам нужно создавать пользователя без імені но сохранив етот функціонал , то есть візівать класс без передачи аргумента

//1. создаем еще один конструктор , но тут же мі видим ошибку і что бі ее исправить нам нужно создать еще один конструктор куда мі передадим описание того что будет передаваться как аргумент в самій ніжній конструктор
//2. теперь наш параметр последнего конструктора делаем необязательним параметром так как ми то можем передать імяа можем і не передать
// 3. теперь в последнем конструкторе пишим условие еоторое проверяет что наш аргумент ето строка

const user3 = new User()

// ------------------------------------------------------------
// теперь нашему классу добавляем свойство возвраст
const user4 = new User(33)

// 1.создаем еще один конструктор с возврастом
// 2.в главном конструкторе создаем юніон тип ,тоесть вписуем возвраст, то есть может принимать либо возвраст либо імя
// 3.добавляем еще одну ветку нашего условия где проверяем на тип намбер і заполняем наш age


// !!!!!!!!!!!!!!!создаем новий конструктор і делаем дополнение нашему главному контсруктору і создаем еще одну ветку условія где  проверяем наш возвраст что бі унас білі такие варіанти :
/* 1. ми нечего не передали
   2. ми передали только имя
   3.ми передали только возвраст
   4.ми передали і возвраст і імя 
   
   Тоесть нижний конструктор должен принимать параметрі а верхнии конструкторі которіе мі візіваєем в класе должні описівать все возможніе варінті передачі аргумента классу.
   В главном варіанте мі написали что параметрі не обязательні при помощи знака *?*, то есть мі указали что они могут біть а могут і не біть, і так же мі указали что может передаваться лібо номер лібо стрінга ілі і номер і стрінга і сверху мі ето описали*/
   


   //=============================================== methods in class

enum PaymentStatus {
    OnCard,
    Process,
    Reversed
}

class Payment {
    id: number;
    status: PaymentStatus;
    createdAt: Date;
    updatesAt: Date;

    constructor(id: number) {
        this.id = id;
        this.createdAt = new Date();
        this.status = PaymentStatus.OnCard;
    }

    getPaymentLifeTime(): number {
        return new Date().getTime() - this.createdAt.getTime()
    } // - создали метод которий показует время от создания до текущей даті
}

const payment = new Payment(1)
const time = payment.getPaymentLifeTime()
console.log(time);

// упражнение c перегрузкой методов

class UserA {
    skills: string[];

    addSkill(skill: string): void;
    addSkill(skills: string[]) : void;
    addSkill(skillOrSkills: string | string[]) : void {
        if (typeof skillOrSkills === 'string') {
            this.skills.push(skillOrSkills)
        } else {
            this.skills.concat(skillOrSkills)
        }
    }
}

new UserA().addSkill('JS')

// ===================== перегрузка функцій

function run(smth: string): string
function run(smth: number) : number
function run(smth: string | number): string | number {
    if (typeof smth === 'string') {
        return ""
    } else {
        return 1
    }
}

/* То есть тут ми видим что в функцию приходит либо стринга либо номер, сверху ми ето описуем перезагрузкой. И в теле функціі нам обязаттельно нужно сделать условие где проверить что пришло и в соответсвии вернуть либо стренгу либо намбер!!!!!!!!!!!!!!!!!!!!!!!!!!!! потому что ми указали что функция должна вернуть либо намбер либо стрингу*/